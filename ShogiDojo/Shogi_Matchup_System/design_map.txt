One HelloThread
HelloThread create communicate token, return the location of CoreThread
( CoreThread == Actual Server )
The client use token to register game in CoreThread
CoreThread matches game, when a game is matched, server respond the client,
and create a GameThread to deal with that game.
A GameThread doesn't have a socket, it use a event queue to work up,
the client use its token to communicate with game, the CoreThread push event queue by
binding the GameThread with both player's token.
After any move, the client return both player the new board state
After winloss, the client declare the winner, change the player rank in database.
and respond both client.
CoreThread close up the game, client return to the page.

Communicate with CoreThread, b64encode with three field, header, token, and actual data

header = GameMove, this packet is used to play a move
header = Register, this packet is used to register a game match
header = Cancel, this packet is used to cancel a register
header = Exception, this packet is used to inform matchup server for exception (like disconnection)

client -> Register
Accept <- CoreThread
Complete <- CoreThread
client -> Accept / Reject
// if no respond in serval seconds, see as reject

client -> Register
Accept <- CoreThread
client -> Cancel
Accept <- CoreThread


token_to_gamethread = dict()
token_to_player = dict()
player_to_token = dict()

while True:
	data = core_server.recvall()
	header, token, event = Parse(data)
	
	if header == 'GameMove':
		gt, flag = token_to_gt[token]
		if not flag:
			log('another player invalid move.')
			continue
		gt.event_queue.push(event)



g = GameThread(token_of_playerA, token_of_playerB)
g.event_queue.push(a_move)


If any invalid move is inputed, log the error message, and ignore.

