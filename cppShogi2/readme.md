新的設計！

有鑑於前面一個的 Code 有點髒，並且冒出了一些新的想法，進行的一次完全重寫。

這裡來完整地描述一下整體的邏輯：

將棋遊戲的進行，主流程分成兩個步驟、

	1.	判讀盤面，列出所有可行的移動。
	2.	讀入行動，更新盤面。

如果 1. 結束以後不存在任何一個可行的移動，此情況執棋方敗。

大部分盤面邏輯的實做都採用盡量低階的原則，來增加速度，因此去你的 OOP。

這裡走火入魔了一下，在這次實做裡甚至捨棄了盤面的二維邏輯，強行把二維壓到一維來處理。

再走火入魔了一下，用 unsigned 負數會往前溢位的特性，讓出界情況可以在四個運算子內處理完畢（雖然包含一個取餘）。

最終的位置編號如下（先手視角），各種出界的狀況額外做出一行來判定。

	x	9	8	7	6	5	4	3	2	1	x
	-1	00	01	02	03	04	05	06	07	08	09	1
	10	11	12	13	14	15	16	17	18	19	20	2
	21	22	23	24	25	26	27	28	29	30	31	3
	32	33	34	35	36	37	38	39	40	41	42	4
	43	44	45	46	47	48	49	50	51	52	53	5
	54	55	56	57	58	59	60	61	62	63	64	6
	65	66	67	68	69	70	71	72	73	74	75	7
	76	77	78	79	80	81	82	83	84	85	86	8
	87	88	89	90	91	92	93	94	95	96	97	9

全部強制在 uint8_t (unsigned char) 下處理。

一些盤面邏輯的轉換：

	先手向前（後手向後） = -11	
	先手向後（後手向前） = +11
	先手向左（後手向右） = -1
	先手向右（後手向左） = +1

	出界： pos > 96, pos % 11 > 8
	先手陣：pos < 31
	後手陣：pos > 65

舉例：先手桂跳 = -23, -21，後手桂跳 = 21, 23

由於本將棋所有棋駒都是對稱移動的，因此所有後手向量 = 先手向量 * -1。 

盤面表示依然使用編號來紀錄，實際紀錄的內容如下：

unsigned char board[97];		// 紀錄在對應格子上的棋駒編號（有效編號由 1 到 40，0 表示盤面對應格為空）

這裡為了加速計算，固定先手王將的編號為 1，後手王將的編號為 2。剩餘就都可以。

short goma_pos[41];				// 紀錄對應棋駒編號的位置（位置 = 0 ~ 99，0 ~ 96 對應棋盤位置、97 為先手駒台、98 為後手駒台）

unsigned char goma_cde[41];		// 紀錄對應棋駒編號的屬性（屬性透過編碼進行）

	屬性編碼：

	0 0 1 1 1 1 1 1

			  0 0 0 步兵
			  0 0 1 香車
			  0 1 0 桂馬
			  0 1 1 銀將
			  1 0 0 角行
			  1 0 1 飛車
			  1 1 0 金將
			  1 1 1 王將

			0 		未升變
			1		升變

		  0			屬於先手
		  1			屬於後手

		0			位於場上
		1			位於駒台

	0 0				保留位

和原先不同的地方，大概就是編碼的順序統整了一下，還有放棄 int 浪費的 3 個 byte。

效率而言應該是沒有差啦，但能省則省。

棋駒移動的編碼：

	unsigned short move;

	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	                  x x x x x x x		舊位置	(<<0)
	    x x x x x x x 					新位置	(<<7)
	  x									是否升變	(16384)
	x									是否打入	(32768)


棋駒的移動邏輯，用一個 array hard_coded 起來，應該比以前更有記憶讀存取的效率，

當初在寫這個專案的時候還沒學過 cache，希望能夠在這之上加速一下。

關於對特定盤面進行存取，可以完全使用 goma_pos 和 goma_cde 兩個陣列來完成。

捨棄掉冗餘的編號 0，最少只需要 80 bytes 就可以完成存取。

但其實使用整個 Class 來存取也只有 81 + 82 = 163 bytes 的花費而已，

因此直接以重載 = 運算子來進行。或是分成兩種：

	normal save/load : cost 163 bytes，<class Shogi> <-> <class Shogi>
	extracted save/load : cost 80 bytes, <class Shogi> <-> <unsigned char[80]> 

目前先弄 normal 的，有需要的話再把 extracted 的弄出來。

在 Class 中所有簡單資料結構均以手寫進行簡化、

對外的輸出界面則是 vector，像是 movelist 等。


FetchMove (core.cpp) 是整份專案最麻煩的函數，他接受一個 unsigned char 的參數，

回傳一個 vector，該 vector 內包含所有在該 mode 下可行的 move。

mode 以數值進行判定，數字越大表示規則越嚴格：

	mode = 0, simple, 		考慮棋駒的移動規則，和二步，和王手無視。
	mode = 1, standard，		多考慮打步詰。
	mode = 2, tsumi,		只考慮必須造成王手。

由於性質特異，千日手和連續王手千日手不在考慮範圍內，

這份專案也不會實做，如果需要實做的話、用 80 bytes 的存取邏輯，

加一個 hash table 來進行例外處理應該就沒問題了。

再來就是 FetchMoves 的過程，這邊由於重寫的途中又一次 mindburst，

可以說把之前的架構砍的差不多了。要說最核心的不同之處就是，

「可不可以透過先搜尋對方的行動，直接在己方行動把王手無視處理完成？」

若是作的好的話，效率可以再上昇一個等級，答雸當然是可以。

新的 FetchMoves Workflow 大概長這個樣子：

	1.	檢查對手的移動可能性，預先處理對己方王將的間接威脅，並記錄直接威脅。
	2.	根據直接威脅來處理己方的移動向量。
	3.	特判打步詰（mode = 1）
	4.	在剩下來的 move 中，找到那些能造成王手的 move。（mode = 2）

1 結束後，產生的 direct_attack_graph 會直接記錄誰有能力攻擊到哪一格。

由於是為了拿來紀錄王將的攻擊的，並且王將不可能遭受兩個以上的直接攻擊，因此這個做法在王將上可以保持正確性。

產生的 flow_attack_graph 則會記錄這一格可以被哪種流向攻擊到，剛好 8 個向量。

間接威脅的部份，則只紀錄王將四周的八個方向，用 16 個 bytes 紀錄方向和攻擊者。

王將可能遭受的所有攻擊就這樣被 <40 bytes 紀錄起來了，還追蹤了誰可以攻擊到這一個格子。

於是根據這個紀錄，在進入 2. 時可以建立起 3 個 flag，

	fast_leave_flag : 雙王手發生時立起
	dpos_flag : 王手時立起
	no_placing_flag : 被直接攻擊時立起

並在發生單一個王手，且為流攻擊時，尋找攻擊者和王之間的直線，建立一防守位置查詢表(dpos)。

dpos_flag 立起時，只有 npos 為 dpos 的行動可以進入。（或王將逃跑）

直接王手時，只有一個 dpos，即為攻擊者的位置，此時不可能打入，因此增加 no_placing_flag 進行優化。

尋找各種 move 的順序，最終看起來會像是這個樣子：

	找王將移動的幾個 move。
	if fast_leave, return （被雙王手提前離開）
	找各種行動向量
		if no_placing_flag, 無視不在場上的 goma。
		如果 dpos_flag，檢查該 dpos 是否為 true
		如果 critical_blcoking，檢查是否和關鍵方向同向
		如果發生了「打入步兵在敵方王將面前」的 move，不要加入 move，反之、立起 uchifu_flag
	檢查 uchifu tsumi，決定要不要加入這個 move。

一個細節到不能再細節的實做，critical_blocking 的所有 blocker 會排個序（最多 8 個），

這樣照著順序瀏覽 goma 時，就可以做簡單判斷第一個來處理 critical_blocking 的問題。（之前的實做每次都會掃過整條 blocker_list）

比起以前的搜索邏輯，不需要像個白痴一樣找多次所有的 move，效率可以再上一層。

外加上各種編碼的內建和一維判定，應該可以很好的進步。

2021/2/16 除了打步詰以外大抵完成了，除錯看起來沒什麼問題，但僅只是看起來而已，等待永無止盡的除錯。

code 壓到 300 行左右完成，甚至比以前要短！雖然可讀性是個慘劇。

未加入打步詰的情況下，`g++ *.cpp -O3` 後用 `time` 指令去測試的話，隨機步行的一局大約是 1.7ms 左右，

同樣環境下，原先的 code 需要大約 3.7ms，兩倍增長。

更正，1.7ms 是筆電沒插電，被壓 CPU 的結果，插了電後，隨機步行來到了 1.1ms 左右，

對應的原版作法則是 2.2 ms 左右，也差不多是兩倍增長。

寫了打步詰的邏輯和增加了一些 manual test case，完全版的新作法，隨機步行一局大約是 1.1ms，

打步詰檢查幾乎沒有耗費新的資源（一方面也是不容易檢查到）。

寫了一個極度簡單的 Makefile。至此專案更新大概差不多了，剩下來就是除錯了。