新的設計！

有鑑於前面一個的 Code 有點髒，而且沒有考慮到和 Python 的向性，
基於原先的邏輯進行的一次完全重寫。

這裡來完整地描述一下整體的邏輯：

將棋遊戲的進行，主流程分成兩個步驟、

1.	判讀盤面，列出所有可行的移動。
2.	讀入行動，更新盤面。

如果 1. 結束以後不存在任何一個可行的移動，此情況執棋方敗。

位置的實際編號如下（棋盤先手視角），各種出界的狀況額外做出一行來判定。

	x	9   8   7   6   5   4   3   2   1	x
	00	01	02	03  04  05  06  07  08  09	10	x
	11  12  13  14  15  16  17	18	19	20	21	1
	22  23  24  25  26	27	28	29	30	31	32	2
	33	34	35	36	37	38	39	40	41	42	43	3
	44	45	46	47	48	49	50	51	52	53	54	4
	55	56	57	58	59	60	61	62	63	64	65	5
	66	67	68	69	70	71	72	73	74	75	76	6
	77	78	79	80	81	82	83	84	85	86	87	7
	88	89	90	91	92	93	94	95	96	97	98	8
	99  100 101 102 103 104 105 106 107 108 109	9
	110 111 112 113 114 115 116 117 118 119 120 x

位置必須使用 signed 的判定

先手向前（後手向後） = -11
先手向後（後手向前） = +11
先手向左（後手向右） = -1
先手向右（後手向左） = +1

出界： pos < 12, pos > 108, (pos + 1) % 11 <= 1

先手桂跳 = -23, -21，後手桂跳 = 21, 23

由於本將棋所有棋駒都是對稱移動的，因此所有後手向量 = 先手向量 * -1。 

盤面表示依然使用編號來紀錄，實際紀錄的內容如下：

unsigned char board[121];		// 紀錄在對應格子上的棋駒編號（有效編號由 1 到 40，0 表示盤面對應格為空）
unsigned char goma_pos[41];		// 紀錄對應棋駒編號的位置（位置 = 0 ~ 122，0 ~ 120 對應棋盤位置、121 為先手駒台、122 為後手駒台）
unsigned char goma_cde[41];		// 紀錄對應棋駒編號的屬性（屬性透過編碼進行）

	屬性編碼：

	0 0 1 1 1 1 1 1

			  0 0 0 步兵
			  0 0 1 香車
			  0 1 0 桂馬
			  0 1 1 銀將
			  1 0 0 角行
			  1 0 1 飛車
			  1 1 0 金將
			  1 1 1 王將

			0 		未升變
			1		升變

		  0			屬於先手
		  1			屬於後手

		0			位於場上
		1			位於駒台

	0 0				保留位

unsigned char id_mask = 7;
unsigned char full_id_mask = 15;
unsigned char owner_mask = 32;
unsigned char board_mask = 64;

和原先不同的地方，大概就是編碼的順序統整了一下，還有放棄 int 多出來的 3 個 byte。
效率而言應該是沒有差啦，但能省則省。
另外一些有關編碼的 code，會寫成巨集來增加效率。

棋駒移動的編碼：

unsigned short move;

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                  x x x x x x x		舊位置
    x x x x x x x 					新位置
  x									是否升變
x									是否打入


棋駒的移動邏輯，用一個 array hard_coded 起來，應該比以前更有記憶讀存取的效率，
當初在寫這個專案的時候還沒學過 cache，希望能夠在這之上加速一下。

關於對特定盤面進行存取，可以完全使用 goma_pos 和 goma_cde 兩個陣列來完成。
捨棄掉冗餘的編號 0，最少只需要 80 bytes 就可以完成存取。
但其實使用整個 Class 來存取也只有 81 + 82 = 163 bytes 的花費而已，
因此直接以重載 = 運算子來進行。或是分成兩種：

	normal save/load : cost 163 bytes，<class Shogi> <-> <class Shogi>
	extracted save/load : cost 80 bytes, <class Shogi> <-> <unsigned char[80]> 

目前先弄 normal 的，有需要的話再把 extracted 的弄出來。

在 Class 中所有簡單資料結構均以手寫進行簡化、
對外的輸出界面則是 vector，像是 movelist 等。


FetchMove (core.cpp) 是整份專案最麻煩的函數，他接受一個 unsigned char 的參數，
回傳一個 vector，該 vector 內包含所有在該 mode 下可行的 move。

mode 以數值進行判定，數字越大表示規則越嚴格：

mode = 0, raw, 			考慮棋駒的移動規則，和二步。
mode = 1, simple,		多考慮王手無視。
mode = 2, standard，		多考慮打步詰。
mode = 3, tsumi,		只考慮必須造成王手。

由於性質特異，千日手和連續王手千日手不在考慮範圍內，
這份專案也不會實做，如果需要實做的話、用 80 bytes 的存取邏輯，
加一個 hash table 來進行例外處理應該就沒問題了。

在 Fetch 進行中，會順手紀錄一份盤面邏輯，來幫助排除棘手的王手無視和打步詰。
這個盤面邏輯的長相如下：

unsigned char direct_attack_graph[81];
索引為位置、有 0, 1, 2, 3 四個值，分別表示沒有直接攻擊、先手直接攻擊、後手直接攻擊、先後手皆可直接攻擊
直接攻擊是指像是金銀那樣，不能被阻擋的攻擊。

unsigned char first_flow_attack_graph[81];
索引為位置、有 0, 1, 2, 3 四個值分別表示沒有流攻擊、先手流攻擊、後手流攻擊、先後手皆可流攻擊
流攻擊是指像角行、飛車那樣，可以被阻擋的攻擊。
流攻擊進行紀錄時，「穿過對方王將」。

unsigned char second_flow_attack_graph[81];
索引為位置、有 0, 1, 2, 3 四個值，分別表示沒有間隔流攻擊、先手間隔流攻擊、後手間隔流攻擊、先後手皆可間隔流攻擊
間隔流攻擊是指流攻擊、但直線移動上遭到某棋駒阻擋。

unsigned char owner_fatal_weakness[8];
己方王將遭到間隔流攻擊，這個值表示來自王將八個方向的流攻擊，
如果沒有，為 0，否則該值為阻擋者的編號。

unsigned char rival_fatal_weakness[8];
敵方王將遭到間隔流攻擊，這個值表示來自王將八個方向的流攻擊，
如果沒有，為 0，否則該值為阻擋者的編號。

原先這些邏輯全數紀錄在 Class 裡，想著反正每次都會清掉，也沒什麼意義，
如果學習時可能會有點幫助，可以再想著用 vector dump 出來。


判定打步詰：

唯有該 move 打入步兵在對方王將面前時會考慮這個邏輯。
如果對方王將四周有沒有被直接攻擊、流攻擊的位置，打步詰不成立。
如果對方王將四周並非間隔流攻擊的阻擋者的棋駒可以取走步兵，
或是間隔流攻擊的阻擋者可以在同一條值線上取走該步兵，打步詰不成立。
為了判斷這件事情，羅列出所有該步兵四周可以移動到這格的敵方棋駒，
並和 rival_fatal_weakness 來比較即可。
反之，打步詰成立。該 move 不合法。

判定王手無視：

如果王將被間隔流攻擊，任何將己方阻擋者偏離阻擋方向的移動都不合法。
如果只有兩王手，只有「王將移動到安全位置」這類移動合法。
如果只有單王手，「王將移動到安全位置」、「取走攻擊者」、「阻擋流攻擊」三者皆成立。

照順序判斷下來即可。