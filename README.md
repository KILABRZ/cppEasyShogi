# cppEasyShogi introduction
- compile by g++ shogi.cpp position_code.cpp main.cpp。
- 從 pythonEasyShogi 而來，移植到 C++ 上的簡單將棋邏輯實作。
- 重視效能，還沒有「打步詰」和「王手無視」這兩個反則的使用，想好方法時會考慮寫進去。
- main.cpp 是一個雙方隨機下棋的測試，一盤毫無思考、不顧慮王將的棋，可以在 30ms 內結束。
- 可以參考 main.cpp 以進行其他方式的實作。
- 對於簡單印出棋盤的好方法還在仔細考慮中。

# change from pythonEasyShogi
- 重新審視了架構、減少了不必要的檢查，使架構更容易理解。
- 重蓋了 python 求簡單的架構，時間上快了 10 倍左右、空間方面可以說毫無負擔。
- 為將棋遊戲的每個部分做出了編碼，棋駒、棋種、位置、行動等都被編碼成數字。
- 承上，可以說將將棋換成了行動／狀態的轉移機器。

# coding Shogi
- 棋駒(goma)：共 40 枚，分給 0 ~ 39 的固定數字，此編號不會因為任何行為（升變、打入、取走）而被改變。
  - 每一枚棋駒有兩個屬性：棋位置(gomaPos)、棋種(gomaKinds)
- 棋種：將棋一共有 8 種基本棋、升變、和所屬人，剛好是 32 種。
  - 編碼方法：chesser(0/1) + upgraded(0/1) + gomacode(000~111)
  - 在實作裡以 int 存起，但實際上只需要用 char 便可。
- 棋位置：9x9 共 81 個位置，以數字存起。
  - 可以用 posSuji、posDan 和 genPos 互換筋、段的常用表示。
  - 在實作裡以 int 存起，但實際上只需要用 char 便可。
- 棋盤(board)：一個長度為 81 的陣列，index 表示棋位置、存放棋駒編號或是空格(-1)。
- 駒台(gomatable)：一個長度為 80 的陣列，分成一半表示先手／後手駒台上有沒有該編號的棋駒(40個)。
- 行動(move)：以以下方法進行編碼：
  - (newpos * 81 + prepos) * 4 + uflag * 2 + nflag
  - newpos：移動到的棋位置。
  - prepos：從何移動而來。可以是駒台或是棋位置。
  - uflag：0 或 1，prepos 由駒台而來、或是棋位置而來。
  - nflag：0 或 1，此行動伴隨著升變。
  - 在實作裡以 int 存起，但實際上只需要用 short。
# future
- 實作效能優秀的王手判定、和打步詰判定。
- 實作效能優秀的 rule-based 搜索、以利機器學習或是其他用途。
- 實作詰將棋解題器。
